{
  "rules": [
    {
      "type": "prd",
      "content": "# 내부 Meta 광고 FAQ AI 챗봇 – PRD (MVP)\n\n## 1. 제품 한줄 요약\nMeta(Facebook·Instagram·Threads) 광고 집행 관련 내부 문서와 지정된 URL만을 근거로, 전사 직원(약 200명)이 한국어로 즉시 질문하고 정확한 답변을 받을 수 있는 RAG 기반 AI 챗봇.\n\n## 2. 배경 & 기회\n- 사내 광고 가이드라인·정책·FAQ가 여러 저장소에 흩어져 있어 직원들이 정보를 찾는데 평균 15분 이상 소요.\n- 헬프데스크에 반복 FAQ 문의가 많아 월 40%의 업무 시간을 소모.\n- 최신 정책 확인 지연으로 광고 집행 오류가 발생, 캠페인 지연·비용 손실 발생.\n\n## 3. 문제 정의 (Pain Points)\n1. 흩어진 자료로 인한 검색·확인 시간 과다.\n2. 반복 FAQ 처리로 운영팀 과부하.\n3. 정책 최신 버전 여부를 직원이 직접 검증해야 하는 번거로움.\n\n## 4. 목표 (User Goals)\n1. 최신 광고 정책·가이드라인을 즉시 확인해 오류 없는 캠페인 집행.\n2. 복잡한 문서를 읽지 않고도 핵심 정보를 빠르게 얻기.\n3. 헬프데스크 문의 없이 자율적으로 문제 해결.\n4. 과거 Q&A 히스토리를 활용해 효율적인 업무 진행.\n\n## 5. 핵심 사용자 & 규모\n- 전사 직원 중 약 200명 (마케팅, 퍼포먼스, 운영팀 등)\n- 관리자(캡틴): 문서 업로드·동기화, 로그 모니터링, 피드백 수집 담당\n\n## 6. 주요 사용 시나리오\n1. 직원이 한국어로 질문 → 챗봇이 관련 문서에서 근거를 찾아 답변 + 출처·최신 업데이트 일자 표시.\n2. 직원이 답변을 즐겨찾기해 저장 후 재사용.\n3. 관리자(캡틴)가 새 정책 PDF 업로드 → 자동 인덱싱 후 즉시 반영.\n4. 관리자 대시보드에서 최근 90일 질문·답변 로그와 피드백 통계 확인, 개선 포인트 파악.\n\n## 7. 기능 범위 (MVP)\n### 7.1 필수 기능\n1. 문서 업로드/동기화 (관리자 전용)\n   - 지원 포맷: PDF, DOCX, TXT, 지정 URL 크롤링\n   - 업로드 후 자동 인덱싱 & 벡터 저장\n2. 자연어 Q&A 챗 UI (한국어 전용)\n   - 실시간 스트리밍 답변\n   - 출처 하이라이트 + 문서 최신 업데이트 일자 표시\n3. Q&A 히스토리 & 즐겨찾기 (개인별)\n4. 실시간 피드백(👍/👎) 수집\n5. 관리자 대시보드\n   - 사용 통계(질문 건수, 활성 사용자수, 피드백 점수)\n   - 질문·답변 로그 열람(최근 90일) + 검색\n6. 보안/권한\n   - 직원: 질문 및 개인 히스토리 조회\n   - 관리자: 업로드, 대시보드, 로그 열람\n\n### 7.2 제외(Out of Scope)\n- 다국어 지원\n- 팀/부서별 접근 권한 세분화\n- 결제 시스템, 실시간 협업 기능\n\n## 8. 비기능 요구사항\n- 응답 속도 ≤ 3초 (평균)\n- 동시 접속 50명까지 성능 보장\n- 데이터 저장: 한국 리전\n- 로그 보존: 90일 후 자동 삭제 (GDPR/개인정보 법 준수)\n- 접근 제어: SSO(SAML) 또는 사내 OAuth 예정\n\n## 9. 성공 지표 (MVP 기준, 3개월)\n- 질문당 평균 탐색 시간 15분 → 2분 이하\n- 헬프데스크 FAQ 문의 건수 50% 감소\n- 주간 활성 사용자(WAU) 60명 이상\n- 사용자 피드백 긍정률(👍) 80% 이상\n\n## 10. 일정 (T0 ~ T6주)\n| 주차 | 목표 |\n|------|------|\n|1주| 프로젝트 세팅, 데이터 모델 설계, UI 와이어프레임|\n|2주| 문서 업로드/인덱싱, 기본 챗 UI 완성|\n|3주| RAG 파이프라인, 출처 표시, 히스토리 기능|\n|4주| 대시보드, 피드백, 로그 보관 로직|\n|5주| 통합 테스트, 보안 점검, 파일럿 배포|\n|6주| 피드백 반영, 안정화, MVP 공식 배포|\n\n## 11. 위험 & 대응\n- 문서 업데이트 누락 → 정기 크론 동기화 + 알림\n- 모델 부정확 답변 → 피드백 루프, 랭크스미스 리랭킹 적용\n- 개인정보 포함 문서 업로드 → 관리자 검수 절차\n\n## 12. 가정\n- 사내 SSO 연동 가능\n- 초기 데이터 500문서, 일 변동 5문서 이하\n- 클라우드 비용 월 200달러 이내\n\n## 13. 향후 로드맵(후-MVP)\n- 영어 지원, 팀별 권한, 모바일 앱, 서드파티 슬랙 연동",
      "writedAt": "2025-09-02T05:24:44.318Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: RAG(Retrieval-Augmented Generation) 기반의 AI 챗봇을 구축하여 Meta 광고 집행 관련 내부 FAQ에 대한 즉각적인 한국어 답변을 제공합니다. Next.js 프론트엔드와 FastAPI 백엔드를 사용하여 전체 시스템을 구축하고, Supabase Postgres 데이터베이스와 pgvector를 사용하여 효율적인 벡터 검색을 구현합니다.\n- **Core Technology Stack**: Next.js 15, TypeScript, React, shadcn/ui, tailwindcss, lucide-react, @tanstack/react-query, Supabase Postgres, pgvector, Python, FastAPI, LangChain, Ollama, Whisper, Tesseract, Slack API, Stripe, Vercel, date-fns\n- **Key Technical Objectives**: 평균 3초 이내의 응답 시간, 최대 50명의 동시 사용자 지원, 90일 질문/답변 로그 보존, 80% 이상의 긍정적 사용자 피드백.\n- **Critical Technical Assumptions**: 사내 SSO(SAML) 또는 OAuth 연동 가능, 초기 데이터 500문서, 일 변동 5문서 이하, 클라우드 비용 월 200달러 이내.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Frontend Framework | Next.js 15                  | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 통한 성능 향상, 라우팅 및 API 핸들링 용이성 |\n| Language          | TypeScript                  | 정적 타입 검사를 통한 코드 안정성 및 유지보수성 향상 |\n| UI Library         | React                       | 컴포넌트 기반 개발 및 재사용성, 활발한 커뮤니티 지원 |\n| UI Components     | shadcn/ui                   | Tailwind CSS 기반의 재사용 가능한 UI 컴포넌트 제공, 디자인 시스템 일관성 유지 |\n| Styling           | tailwindcss                 | 유틸리티 기반 CSS 프레임워크, 빠른 스타일링 및 반응형 디자인 지원 |\n| Icons             | lucide-react                | 고품질의 SVG 아이콘 제공, UI 디자인 일관성 유지 |\n| Data Fetching     | @tanstack/react-query       | 서버 상태 관리 및 캐싱, 효율적인 데이터 패칭 및 업데이트 |\n| Database          | Supabase Postgres           | 안정적인 오픈 소스 관계형 데이터베이스, 확장성 및 보안성 |\n| Vector Store       | pgvector                    | Postgres 확장, 임베딩 벡터 저장 및 유사도 검색 기능 제공 |\n| Backend Framework | Python, FastAPI             | 고성능 API 개발, 비동기 처리 지원, 빠른 개발 속도 |\n| LLM Framework     | LangChain                   | LLM(Large Language Model) 통합 및 관리, RAG 파이프라인 구축 용이성 |\n| LLM               | Ollama                      | 로컬 LLM 실행 및 관리, 개인 정보 보호 및 낮은 지연 시간 |\n| Speech-to-Text    | Whisper                     | 음성 데이터를 텍스트로 변환, 음성 기반 질문 지원 (향후 확장 고려) |\n| OCR               | Tesseract                   | 이미지 기반 문서에서 텍스트 추출, 다양한 문서 형식 지원 |\n| Slack Integration | Slack API                   | Slack 알림 및 통합 기능 제공 (향후 확장 고려) |\n| Payment           | Stripe                      | 결제 시스템 연동 (제외 기능이지만 향후 확장 고려) |\n| Hosting           | Vercel                      | Next.js 애플리케이션 배포 및 호스팅, 자동 스케일링 및 CDN 지원 |\n| Date Library      | date-fns                    | 날짜 및 시간 관련 기능 제공, 일관성 있는 날짜 처리 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js)**: 사용자 인터페이스 및 사용자 상호 작용을 처리합니다.\n    - UI 컴포넌트 (React, shadcn/ui)\n    - 데이터 패칭 및 상태 관리 (@tanstack/react-query)\n    - 라우팅\n- **Backend (FastAPI)**: API 엔드포인트 및 비즈니스 로직을 처리합니다.\n    - API 엔드포인트 (FastAPI)\n    - RAG 파이프라인 (LangChain, Ollama)\n    - 데이터베이스 상호 작용 (Supabase Postgres, pgvector)\n- **Database (Supabase Postgres)**: 문서 데이터 및 임베딩 벡터를 저장합니다.\n    - 문서 데이터\n    - 임베딩 벡터 (pgvector)\n    - 사용자 히스토리 및 즐겨찾기\n- **External Services**: Slack API, Stripe (향후 확장 고려)\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n    A[Frontend (Next.js)] --> B[Backend (FastAPI)]\n    B --> C[Database (Supabase Postgres)]\n    B --> D[LLM (Ollama)]\n    B --> E[LangChain]\n    B --> F[pgvector]\n```\n\n- Frontend (Next.js)는 사용자 인터페이스를 통해 질문을 받고 Backend (FastAPI)로 요청을 전송합니다.\n- Backend (FastAPI)는 LangChain을 사용하여 RAG 파이프라인을 실행하고, Ollama를 통해 LLM을 호출하여 답변을 생성합니다.\n- Backend (FastAPI)는 Supabase Postgres 데이터베이스와 pgvector를 사용하여 문서 데이터 및 임베딩 벡터를 저장하고 검색합니다.\n- Backend (FastAPI)는 Frontend (Next.js)로 답변 및 출처 정보를 반환합니다.\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: `user`, `document`, `chatbot`, `admin` 등의 도메인으로 분리합니다.\n- **Layer-Based Architecture**: `presentation` (UI), `application` (비즈니스 로직), `domain` (도메인 모델), `infrastructure` (데이터 액세스, 외부 서비스) 레이어로 분리합니다.\n- **Feature-Based Modules**: 각 기능별로 모듈을 구성합니다 (예: `upload`, `search`, `feedback`).\n- **Shared Components**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트는 `shared` 모듈에 저장합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── frontend/                      # Next.js 프론트엔드\n│   ├── components/               # React 컴포넌트\n│   │   ├── chatbot/              # 챗봇 관련 컴포넌트\n│   │   ├── ui/                   # shadcn/ui 컴포넌트\n│   │   └── ...\n│   ├── pages/                    # Next.js 페이지\n│   │   ├── api/                # API 엔드포인트\n│   │   ├── _app.tsx\n│   │   └── index.tsx\n│   ├── styles/                   # CSS 스타일\n│   ├── utils/                    # 유틸리티 함수\n│   ├── types/                    # 타입 정의\n│   └── ...\n├── backend/                       # FastAPI 백엔드\n│   ├── app/                      # FastAPI 애플리케이션\n│   │   ├── api/                # API 엔드포인트\n│   │   │   ├── chatbot.py\n│   │   │   ├── document.py\n│   │   │   └── ...\n│   │   ├── core/               # 핵심 로직\n│   │   │   ├── llm.py\n│   │   │   ├── rag.py\n│   │   │   └── ...\n│   │   ├── models/             # 데이터 모델\n│   │   ├── db/                 # 데이터베이스 관련\n│   │   ├── utils/              # 유틸리티 함수\n│   │   └── main.py             # FastAPI 엔트리 포인트\n│   ├── scripts/                  # 스크립트\n│   └── ...\n├── data/                          # 데이터\n├── docs/                          # 문서\n├── .env                           # 환경 변수\n├── README.md                      # README 파일\n└── ...\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Frontend (Next.js)는 API 요청을 Backend (FastAPI)로 전송하고, Backend (FastAPI)는 JSON 형식으로 응답합니다.\n- **Database Interaction**: Backend (FastAPI)는 Supabase Postgres와 pgvector를 사용하여 데이터베이스에 접근하고 쿼리를 실행합니다.\n- **External Service Integration**: Backend (FastAPI)는 LangChain을 통해 Ollama와 통합하여 LLM을 사용합니다.\n- **Data Synchronization**: 데이터베이스의 변경 사항은 필요에 따라 캐싱 또는 실시간 업데이트를 통해 Frontend에 반영합니다.\n\n## 4. Performance & Optimization Strategy\n- **캐싱**: 자주 사용되는 데이터는 캐싱하여 데이터베이스 부하를 줄입니다. (예: @tanstack/react-query 캐싱)\n- **데이터베이스 최적화**: 데이터베이스 쿼리 성능을 최적화하고, 인덱싱을 적절히 활용합니다.\n- **LLM 최적화**: LLM 추론 시간을 줄이기 위해 모델을 최적화하고, 프롬프트 엔지니어링을 통해 답변 품질을 향상시킵니다.\n- **코드 최적화**: 불필요한 연산을 줄이고, 효율적인 알고리즘을 사용하여 코드 실행 속도를 향상시킵니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js, FastAPI, Supabase Postgres, pgvector 설정 및 초기 데이터 모델 설계.\n- **Essential Features**: 문서 업로드/인덱싱, 기본 챗 UI, RAG 파이프라인 구축, 출처 표시 기능 구현.\n- **Basic Security**: 기본 인증 및 권한 관리 구현.\n- **Development Setup**: 개발 환경 설정 및 CI/CD 파이프라인 구축.\n- **Timeline**: 1~3주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 히스토리 기능, 피드백 수집, 관리자 대시보드 구현.\n- **Performance Optimization**: 시스템 성능 개선 및 응답 시간 최적화.\n- **Enhanced Security**: 보안 취약점 점검 및 보안 강화.\n- **Monitoring Implementation**: 시스템 모니터링 및 로깅 설정.\n- **Timeline**: 4~6주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: LLM 답변 품질 저하, RAG 파이프라인 성능 문제.\n    - **Mitigation Strategies**: 피드백 루프를 통해 모델 개선, 랭크스미스 리랭킹 적용, 프롬프트 엔지니어링.\n- **Performance Risks**: 데이터 증가에 따른 응답 시간 증가, 동시 사용자 증가에 따른 서버 부하 증가.\n    - **Mitigation Strategies**: 캐싱, 데이터베이스 최적화, 서버 스케일링.\n- **Security Risks**: 데이터 유출, 권한 없는 접근.\n    - **Mitigation Strategies**: 데이터 암호화, 접근 제어, 보안 감사.\n- **Integration Risks**: 외부 서비스 (Ollama, Supabase) 장애.\n    - **Mitigation Strategies**: 장애 감지 및 자동 복구, 대체 서비스 사용.\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 지연, 예상치 못한 문제 발생.\n    - **Contingency Plans**: 우선순위 재조정, 추가 리소스 투입, 기능 축소.\n- **Resource Risks**: 개발 인력 부족, 기술적 어려움.\n    - **Contingency Plans**: 추가 인력 확보, 외부 전문가 활용.\n- **Quality Risks**: 코드 품질 저하, 테스트 부족.\n    - **Contingency Plans**: 코드 리뷰 강화, 자동화된 테스트 도입.\n- **Deployment Risks**: 배포 실패, 환경 설정 문제.\n    - **Contingency Plans**: 롤백 계획, 자동화된 배포 파이프라인.\n",
      "writedAt": "2025-09-02T05:24:44.318Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-09-02T05:24:44.318Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-02T05:24:44.318Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-02T05:24:44.318Z"
    }
  ]
}